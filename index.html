<!doctype html>
<html lang="en-NZ">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">

		<link rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
		<link rel="icon" type="image/png" href="img/icons/favicon-96x96.png" sizes="96x96">
		<link rel="icon" type="image/png" href="img/icons/favicon-32x32.png" sizes="32x32">
		<link rel="icon" type="image/png" href="img/icons/favicon-16x16.png" sizes="16x16">

		<link rel="apple-touch-icon" href="apple-touch-icon.png" sizes="180x180" />

		<link rel="manifest" href="manifest.json"/>
		<link rel="mask-icon" href="img/icons/safari-pinned-tab.svg" color="#A2DDD9">
		
		<meta name="msapplication-TileColor" content="#A2DDD9">
		<meta name="theme-color" content="#A2DDD9"/>
		<meta name="background-color" content="#fff"/>

		<meta property="og:url" content="https://praesongprasit.github.io/talk_react-told-me-off/" />
		<meta property="og:type" content="article">

		<meta property="og:image" name="twitter:image" content="https://praesongprasit.github.io/talk_react-told-me-off/repository-open-graph_img.png" />
		<meta property="og:image:alt" content="Light text on dark green background which said, Entice 'em, getting engineers excited about accessibility @PraeSongprasit"/>
		<meta property="og:image:type" content="image/png"/>
		<meta property="og:image:width" content="1280"/>
		<meta property="og:image:height" content="640"/>

		<meta property="og:title" name="twitter:title" content="Entice 'em, getting engineers excited about accessibility" />
		<meta property="og:description" name="twitter:description" content="I'm an engineer who cares about HTML output. I still make mistakes. Often, front-end frameworks like React and Angular abstract HTML away. Even more so with design systems built on these frameworks. It's easy to forget to scrutinise the output during implementation. The good news is, these frameworks are aware of the problem, and are constantly getting better at catching low-hanging fruit.
Let me show you a few ways React and React Testing Library told me off!" />

		<meta name="twitter:card" content="summary_large_image">
		<meta name="twitter:dnt" content="on">
		<meta name="twitter:creator" content="@PraeSongprasit">

		<title>Entice 'em - Getting engineers excited about accessibility by Prae Songprasit</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/personal-branding.css" id="theme">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/a11y-dark.css" id="highlight-theme">
	</head>
	<body>
		<div class="reveal">
			<main class="slides">
				<section>
					<h1>Entice 'em</h1>
					<p>Getting engineers<br> excited about accessibility</p>
					<p class="small-text">
						<a rel="external" href="https://twitter.com/PraeSongprasit" alt="Link to Prae Songprasit's twitter">@PraeSongprasit</a> and 
						<a rel="external" href="https://twitter.com/PraeSongprasit" alt="Web Access Club podcast twitter">@WebAccessClub</a>
					</p>

					<aside class="notes">
						<p>Hi, I'm Prae, a Thai woman with shoulder length dark hair. I'm wearing a large pair of dark full-frame glasses and [cloths].</p>
						<p>I've been a UX focused front-end web engineer for 9 years.</p>
						<p>But I actually started my career as a designer. Hence my deep appreciation for design craft, especially UX parts of it.</p>
						<p>I love coding up designs in a responsive manner, and improving usability of those designs through code.</p>
						<p>I spent most of my career focusing on how to make UI design and UX pattern scales.</p>
						<p>I've done that while collaborating closely with designers, to ensure that there is reasonable consistency between implementation and designer's vision. I rely heavily on in-house pattern libraries and design systems to do that.</p>
						<p>I owe a lot of my career to the UX designers and researchers I've worked with. That's apparently most of you. </p>
						<p>You have constantly reminded me of who my users are, and their needs. You've helped me understand our user's feedback after features have been released, and collaborate on a way to incorporate that feedback.</p>
						<p>In the last few years, I've gone even deeper into my front-end craft, and have been focusing my efforts on creating and advocating for accessible interfaces. </p>
						<p>As I advocate, I noticed a different level of enthusiasm for accessibility among all roles. Some are really enthusiastic about it, and some, not so much.</p>
						<p>Over and over, I come accross a theme of sentiments...</p>
					</aside>
				</section>

				<section>
					<blockquote>
						Engineers are less engaged with accessibility
					</blockquote>
					<p>If true... Why is that?</p>

					<aside class="notes">
						<p>Many designers told me that it's hard to get engineers engaged in accessibility.</p>
						<p>Engineers don't seem interested!</p>
						<p>Some even struggle with getting their designs implemented properly in the first place. Let alone in a technically accessible way. </p>
						<p>Assuming that is actually true... The main questin, is why?</p>
						<p>To answer that question, let's take a step back, and treat engineers like… A user.</p>
					</aside>
				</section>

				<section>
					<h2>Engineers as a user</h2>
					<p class="fragment">
						Who are they?
					</p>

					<aside class="notes">
						<p>From my humble understanding of the user centred design practice, you start by empathising with your users. In this case, you'd ask:</p>
						<ul>
							<li>Who are the engineers?</li>
							<li>What do they need to do their job?</li>
							<li>What do they want?</li>
							<li>How they currently do things</li>
							<li>How they'd like to do them</li>
						</ul>
						<hr>
						<p>[Next] First, who are the engineers?</p>
						<p>At a high level, their job is to implement the best possible technological solution to a problem.</p>
						<p>But how does one become an software engineer?</p>
						<p>Like any user group, they come from diverse backgrounds. They could be neurodiverse, disabled, don't have a university degree, and etc.</p>
						<p>But the aspect that I want to highlight, is that not all engineers had formal education related to programming.</p>
						<p>They may haved started their career through a self-taught portfolio or junior talent programme. For non-traditional types, interest in their role is mostly driven by what their work prioritise and teach them</p>
						<p>For traditional types of programmers, they took a degree that taught them nothing about design, and everything to do with how to break down problems and solve it using technologies.</p>
						<p>Unless the engineer was taught or worked closely with design and research, they wouldn't understand how to proactively approach these subjects.</p>
					</aside>
				</section>

				<section>
					<h3>Responsible for...</h3>
					<p>
						Creating, testing, &amp; maintaining software<span class="fragment"><br>in a <em>usable, secure, privacy focused, responsive, scalable, testable, maintainable, performant, efficient, resilient, safe, accessible,</em> and 100+ manner</span>
					</p>

					<aside class="notes">
						<p>In most companies, engineers are expected to create, test and maintain software.</p>
						<p>That's pretty reasonable right?</p>
						<p>The trickier thing, is the manner in which they're expected to engineer software</p>
						<hr>
						<p>[Next]</p>
						<p>We have to engineer software, in a usable, secure, privacy focused, responsive, scalable, testable, maintainable, performant, efficient, resilient, safe, accessible, and 100+ manner</p>
						<p>Not a very readable slide is it? It just goes to show what is on engineer's mind when they're writing that 10 lines of code.</p>
						<p>This is why, writing code is a team sport. And why there'll always be more engineers than designers.</p>
						<p>It's not possible for 1 engineer to be able to write code in all the ways we expect our software to be. It takes different types of engineers with different specialities to make up a team of people, who can collectively do all of this.</p>
						<p>Multiple people will help remind eachother to be accountable for different aspect of software engineering practice.</p>
					</aside>
				</section>

				<section>
					<h3>Need to learn...</h3>
					<div class="r-stack">
						<img
							width="100%"
							src="img/web-dev-roadmap.png"
							alt="">
						<img
							class="fragment"
							width="100%"
							src="img/web-dev-roadmap_greyscale.png"
							alt="">
					</div>

					<aside class="notes">
						<p>In order for us to engineer web application in such ways, many of us will have to learn and use a lot of these tools and concepts</p>
						<p>They may be a front-end focus engineer like myself, a backend person, or a full-stack which covers both side of these learning paths.</p>
						<p>Where does accessibility fits into all this? Well... here [next]</p>
						<p>But as you can see, it's a rather small part of the front-end engineering toolkit and practice. If your developer is backend focused, or is a full-stack, it's even less likely that they'd already how to implement accessible experiences.</p>
					</aside>
				</section>

				<section>
					<h3>Want...</h3>
					<p>Process, priority, simplicity</p>

					<aside class="notes">
						<p>Since engineers are responsible for so many things and have to constantly learn to keep up with the technologies, they want:</p>
						<ul>
							<li>Processes to help them manage their load</li>
							<li>To prioritise things that are more important or pressing</li>
							<li>To simplify as many things as possible.</li>
						</ul>
					</aside>
				</section>

				<section>
					<h3>Want...</h3>
					<p>Processes, priority, simplicity</p>

					<aside class="notes">
						<p>At the very least, they need to know what they're building. A feature? A whole new app? An app that lives inside an app? Or a design system component?</p>
						<p>Engineering </p>
						<p>Many engineers are curious. The good ones, not only want to know what they're building, but why they're building it.</p>
					</aside>
				</section>

				<section>
					<h3>Workload management</h3>
					<img
							width="100%"
							src="img/scrum.webp"
							alt="">

					<aside class="notes">
						<p></p>
					</aside>
				</section>

				<section>
					<img
							width="70%"
							src="img/todo_graphic.png"
							alt="Simplified UI of 4 to-do list states, empty, with an item added, done, and archived">

					<aside class="notes">
						<p>Think of to-do apps. It looks simple, a list title with lists of items.</p>
						<p>But there's a lot more to it than you think. I have to allow users to add whatever text they want as a dismissable list item.</p>
						<p>There's logic to control when a list item should be displayed, when it should appear in the 'done' or an 'archived' state, and when it should be permanently deleted. </p>
						<p>With so much microinteraction and power in the hands of my users, a lot more code could go wrong here. </p>
						<p>If I didn't code the list logic properly, archiving a list item could permanently delete that item by accident.</p>
						<p>And what happens, if someone uses a special character?</p>
						<p>Many JavaScript frameworks like React are designed, so that this sort of complex logic can be done in the browser, without forcing the users to refresh their browser. </p>
						<p>In the early days of the web, most logic that deals with content happens in the server, not the browser. </p>
						<p>So back-end developers who often use traditional imperative programming languages are expected to write tests, to ensure that the logic works as expected under different scenarios. It's good code quality control and development practice.</p>
						<p>But writing logical tests for front-end web interfaces is a much newer concept, especially for me. </p>
						<p>The first unit testing tool I've ever used was the React version of the open source library, called the 'Testing Library'.</p>
					</aside>
				</section>

				<section>
					<h2>React <br>Testing Library</h2>
					<p>Enforce user centric tests</p>

					<aside class="notes">
						<p>This testing library can be added to many front-end frameworks.</p>
						<p>But since I'm working with React, I only know how to use it with React at the moment.</p>
						<p>The Testing Library helps me test UI components in a user-centric way, like the way a user would use a component.</p>
					</aside>
				</section>

				<section>
					<pre>
						<code data-trim data-noescape class="language-html">
							&lt;Button
								label="Add a new fish"
								onClick="this.showFishInput"
							/&gt;
							
							&lt;Input
								aria-label="Fish name"
								class="fishInput"
							/&gt;
							<span class="fragment">
							fireEvent.showFishInput()

							expect(&lt;Input class="fishInput"/&gt;) to render 🤯
							</span>
						</code>
					</pre>

					<aside class="notes">
						<p>For example, I was tasked to write tests for a button that would show an input field.</p>
						<p>On the screen, you can see React Button markup, with label 'add a new fish' and an onClick handler, <br>which will run showFishInput that renders </p>
						<p>Below the button, is input code it suppose to render.</p>
						<p>The input field was marked up with aria-label 'Fish name', and class called 'fishInput'.</p>
						<p>A note that in this example, the function's syntax isn't entirely accurate, <br>and Input field doesn't have a visible label... and used aria-label.... I've only done that to simplified the slide.</p>
						<p>Please get correct syntax from docs, <br>and add a visible label then link it to input using for and ID attribute instead!!</p>
						<hr>
						<p>Anyway...</p>
						<p>In the past, the back-end style of writing tests, would focus on testing the function and implementation itself. In this case, the test would:</p>
						<p>Fire event called showFishInput, and expect an input with class called 'fishInput' to render</p>
						<p>The problem I have with this, is that it only tests if the input field with a class name "fishInput" appears on the page when that code is executed. The test doesn't care if there's an accessible name called "Fish name" attached to that newly rendered input field.</p>
						<p>That's not how users think about this interface.</p>
						<p>Users don't care about a classname? CSS classes are not visible to users on the page; their screen reader won't read it, and voice dictation tools can't find an element using CSS class.</p>
						<p>This, is how you'd write it in React Testing Library</p>
					</aside>
				</section>

				<section>
					<pre>
						<code data-trim data-noescape class="language-html">
							&lt;Button
								label="Add a new fish"
								onClick="this.showFishInput"
							/&gt;
							
							&lt;Input
								aria-label="Fish name"
								class="fishInput"
							/&gt;
							
							userEvent.click(screen.getByText('Add a new fish'));

							expect(
								screen.getByRole('input', { name: 'Fish name' })
							).toBeInTheDocument(); ❤️
						</code>
					</pre>

					<aside class="notes">
						<p>userEvent "Add a new fish" was clicked.</p>
						<p>The test expect an input field with an accessible name called "Fish name" to appear.</p>
						<p>React Testing Library is accessibility-first like that.</p>
						<p>It encourages engineers to write tests that queries accessible names and DOM roles, rather than arbitrary IDs and Classes that users don't care about.</p>
						<p>In this example, I used getByRole to find the input field.</p>
						<p>But you can query or find things in the DOM by other useful static things like ByTitle, ByAltText, ByDisplayValue, even interactive states like pressed, checked, selected.</p>
						<p>This is fantastic, because if the test cannot access those values, then something is seriously inaccessible about your code.</p>
						<p>I once spotted an issue, where a hidden attribute accidentally remained attached to a component that should be displaying.</p>
						<p>The query told me there's a problem because it couldn't find this hidden text.</p>
					</aside>
				</section>

				<section>
					<img
							width="80%"
							src="img/design_system_select_vs_dropdown.png"
							alt="Simplified UI of 2 identical looking interactive elements, which could be a select box or a dropdown. One element's accessible name is Fish habitat, fresh water. Another element's name is Fish habitat.">
					
					<aside class="notes">
						<p>What prompted me to write this talk, was when React Testing Library once helped me spotted that we used the wrong component from our design system.</p>
						<p>On the screen, I've put up UI of 2 identical looking interactive elements, <br>it could be a select box or a dropdown.</p>
						<p>My team needed a dropdown UI, so we quickly picked up one that seems easiest to implement.</p>
						<p>In this example, the dropdown UI had a visible label called fish habitat, that shouldn't change.</p>
						<p>We wrote the test to select an option to display information related to that habitat. In this case, 'fresh water'</p>
						<p>We found out that the dropdown's accesible name after we selected 'fresh water', was 'fish habitat, fresh water'</p>
						<p>We were very confused. Why is did the accessible name changed when something was selected?</p>
						<p>We tested with a screen reader, and it announced the same thing!</p>
					</aside>
				</section>

				<section>
					<img
							width="80%"
							src="img/design_system_select_vs_dropdown_correct.png"
							alt="Simplified UI of 2 identical looking interactive elements. The first element, which is a select input, has a visible label called Fish Habitat, showing that Fresh water option was selected. Its accessible name is Fish habitat, Fresh water. Another element is a custom dropdown menu with both visible and accessible name of Fish habitat.">
					
					<aside class="notes">
						<p>Turns out, the problem was that we used a select component, instead of a dropdown menu.</p>
						<p>Select is a type of input field. It was originally designed for form submissions.</p>
						<p>Usually, a select input field would have a visible label.</p>
						<p>Once an option was selected, the screen reader would read both label and value. Just like any other input fields that was properly related to a label.</p>
						<hr>
						<p>My team saw that the design system component came with an option to hide visible label. The design didn't have one above the trigger, so we enabled that</p>
						<p>Our design sytem team realised that a select input will only annouce the value of 'fresh water' without any context to screen reader users.</p>
						<p>So they tried to be helpful and sets aria-label for the select input as label, and value. Hence the Fresh habitat and fresh water annoucement</p>
						<hr>
						<p>We should have used the dropdown menu component,<br>that was designed to be just a menu of repeatable activities people could do on a page, hence no need to annouce what's selected</p>
						<p>The dropdown accessible name never change.</p>
						<p>Thanks to React Testing Library, it nudge us to reimplement the feature with the right component.</p>
					</aside>
				</section>

				<section>
					<h2>What about React?</h2>
					<p>Improved docs, <br>development assistance, &amp; bundling</p>

					<aside class="notes">
						<p>I talked quite a bit about the React version of Testing Library.</p>
						<p>But as the name suggests, it's a library. Something designed to be used in conjunction with a framework. It's not React itself.</p>
						<p>So what does React itself actually do to help nudge engineers to write more accessible code?</p>
						<p>It ries to improve its docs, and recommend more development assistance, &amp; bundle those recommendations in their starter kit.</p>
						<hr>
						<p>With documentation,</p>
						<p>React understand that beginners copy and paste code quite blindly when learning.</p>
						<p>So their copy-paste examples all throughout their docs are getting better, and more accessibility conscious all the time.</p>
						<p>That is of course, human intervention. Requires reading. What about machine intervention?</p>
						<p>Well, is to recommend basic development assistance</p>
						<hr>
					</aside>
				</section>

				<section>
					<pre>
						<code data-trim data-noescape class="language-html">
							&lt;img src="fishyImage.png"/&gt;

							(image-alt):
							Ensures &lt;img&gt; elements have alternate text
							or a role of none or presentation


							&lt;button tabindex="2"&gt;
								Add a new fish
							&lt;/button&gt;

							(tabindex):
							Ensures tabindex attribute values
							are not greater than 0
						</code>
					</pre>

					<aside class="notes">
						<p>Everyone makes mistakes. Whenever possible, let tools instead of people tell them off.</p>
						<p>There are some basic accessibility linting tools like axe-linter or eslint-plugin-jsx-a11y.</p>
						<p>It would highlight an HTML attribute that isn't right, or is missing for a specific type of element with a red squiggly line like when you made a typo, and would show warnings in the console.</p>
						<p>The example on the screen, shows linting messages for image and a button called Add a new fish with tabindex 2.</p>
						<p>The linting message said:</p>
						<p>that the image needed an alternative text or a role of non or presentation</p>
						<p>For the button, it said that tabindex value should be no greater than 0.</p>
						<p>This is a great way to remind engineers basic things while they're coding.</p>
						<p>The last thing React did, was to recommend good practices in Create React App starter guide</p>
					</aside>
				</section>

				<section>
					<p>Create React App</p>
					<img
							width="40%"
							src="img/create-react-app.svg"
							alt="Create React App logo">

					<aside class="notes">
						<p>Create React App's is a bootstrap kit for starting a new React project.</p>
						<p>React understand that it's crucial to add best practices to starter kits, because that's usually how someone create their first React project.</p>
						<p>React Testing Library and the linting tools mentioned before, were also recommended in Create React App guides, along with other accessibility best practices</p>
					</aside>
				</section>

				<section>
					<h2>People can <br>ignore tests?!</h2>
					<p class="fragment" data-fragment-index="1">
						Yes... but you can make it harder
					</p>
					<aside class="notes">
						<p>But wait… this is real life. Can't people also just ignore or by-pass these tests?</p>
						<p>[Next]</p>
						<p>Yes, and no. Depends.</p>
						<p>For React Testing Library, if you don't write any tests as a part of your usual development process, then of course you won't reap these benefits.</p>
					</aside>
				</section>

				<section>
					<h2>Bake it in</h2>
					<p>
						TDD, prevent commits &amp; stop deploys
					</p>
					<aside class="notes">
						<p>But if your team does test driven development, where you write tests first, then write real code which would fix the test, then React Testing Library will slot right into your workflow </p>
						<p>As for development assistance like linting… You <em>can</em> turn some linting tools off, like additional libraries or extensions attached to your code editor. And frustratingly, many engineers unfamiliar with front-end landscape do. So engineers could simply ignore many linting warnings.</p>
						<p>You can put in the last resort, of making sure that people cannot deploy code without passing accessibility tests and or linters.</p>
						<p>You can chain accessibility linter to the same test command you use before committing, pushing locally, and during build to deploy.</p>
						<p>If the tests fail, then the engineers won't be able to push code or run a successful build and deploy that code to production.</p>
						<p>Let the bots tell people off… rather than your team mates.</p>
					</aside>
				</section>

				<section>
					<h2>React told me off</h2>
					<p>
						...but not all the time
					</p>

					<aside class="notes">
						<p>As you can see, React, React Testing Library, and other accessibility linting tools are trying to improve accessibility in several ways:</p>
						<ol>
							<li><p>It tries to change the way you approach writing tests. To think more along the lines of what users do on the page, and querying accessible names or roles to check if something works as expected</p></li>
							<li><p>It tries to embed basic accessibility as a part of the development process or deployment pipeline</p></li>
							<li><p>It tries to nudge you to add important things like alt tags to images, and accessible names in links and buttons.</p></li>
						</ol>
						<p>It will tell me off, if my element doesn't have an accessible name. But robots don't understand what the 'most usable' accessible name looks like. </p>
						<p>If I wasn't an UX conscious engineer, I may have fixed the issue by putting a random text in as an element's accessible name and calling it the day.</p>
					</aside>
				</section>

				<section>
					<h2>Bots don't know UX</h2>
					<p>
						Good HTML &amp; copy...<br>We need humans for that
					</p>

					<aside class="notes">
						<p>People can't properly address low-hanging issues raised by tooling, without understanding why that was considered an issue.</p>
						<p>They need to understand HTML, yes, but also how copy design fits into the whole experience.</p>
						<p>Copy is a core part of good UX. It's crucial for assistive technologies.</p>
						<p>And as of now, bots hasn't gotten smart enough, to be the judge of what a good copy looks like yet.</p>
						<p>It can't tell if your tab order is all messed up either.</p>
						<hr>
						<p>Another problem, is that new team members who weren't involved in the automated tests and linting tool setup, <br>may incorrectly assume that's it. You're accessible if all tests passed.</p>
						<p>Team needs to create an embeded culture of making things accessible in all part of the process, from research, to design, to criteria writing, to testing to prevent that misunderstanding.</p>
						<p>So yes, React could tell me off for writing some inaccessible code.</p>
						<p>But we still have to rely on human coders, testers, and designers to figure out what makes sense for our UI.</p>
					</aside>
				</section>

				<section>
					<blockquote>
						getting people excited about <br> accessibility <br>=<br>getting them excited about <br>design practice
					</blockquote>
					<p class="small-text">
						<a rel="external" href="https://twitter.com/PraeSongprasit" alt="Link to Prae Songprasit's twitter">@PraeSongprasit</a> and 
						<a rel="external" href="https://twitter.com/PraeSongprasit" alt="Web Access Club podcast twitter">@WebAccessClub</a>
					</p>

					<aside class="notes">
						<p>It's important to remember that accessibility isn't a standalone thing that you can test in isolation.</p>
						<p>It's a mindset of creating a usable experience for everyone.</p>
						<p>It still needs humans to work together to create something truly inclusive.</p>
					</aside>
				</section>
			</main>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				// Display presentation control arrows
				// controls: false,
				slideNumber: true,
				showSlideNumber: print,
				// 16:9 aspect ratio is good for recording and Youtube uploads
				// 1440p 2560x1440
				// 1080p 1920x1080
				// 720p 1280x720
				// width: 1280,
				// height: 720,
				hash: true,
				transition: 'none',
				// Enable for PDF export
				// showNotes: true,
				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
